from rdkit.Chem.Fingerprints import FingerprintMols
from rdkit import DataStructs

def get_similarity(mol_a, mol_b):
    mol_a = Chem.MolFromSmiles(Chem.MolToSmiles(mol_a, isomericSmiles = False))
    mol_b = Chem.MolFromSmiles(Chem.MolToSmiles(mol_b, isomericSmiles = False))
    fingerprint_a = FingerprintMols.FingerprintMol(mol_a)
    fingerprint_b = FingerprintMols.FingerprintMol(mol_b)
    similarity = DataStructs.FingerprintSimilarity(
        fingerprint_a, fingerprint_b
    )
    
    return similarity

from rdkit import Chem

def try_add_atom(mol, atom_id, atom_id_to_idx, hier_graph, vocabs):
    if atom_id_to_idx[atom_id] is None:
        atom_vocab_idx = hier_graph.nodes["atom"].data["vocab_idx"][atom_id]
        atomic_num, formal_charge = vocabs["atom"]["node"][atom_vocab_idx]
        atom = Chem.Atom(int(atomic_num))
        atom.SetFormalCharge(int(formal_charge))
        atom_id_to_idx[atom_id] = mol.AddAtom(atom)

def try_add_bond(mol, source_id, target_id, edge_id, atom_id_to_idx, hier_graph, vocabs):
    source_idx, target_idx = atom_id_to_idx[source_id], atom_id_to_idx[target_id]
    if mol.GetBondBetweenAtoms(source_idx, target_idx) is None:
        bond_vocab_idx = hier_graph.edges["bond"].data["vocab_idx"][edge_id]
        bond_order = vocabs["atom"]["edge"][bond_vocab_idx]
        bond_type = Chem.rdchem.BondType.values[bond_order]
        mol.AddBond(source_idx, target_idx, bond_type)

def hier_graph_to_mol(hier_graph, vocabs):
    """
    Args:
    hier_graph - A DGLGraph representing a molecule,
        i.e. as generated by preprocessing or by the decoder.
    vocabs - A dict of vocabs for the motifs, attachment configs, and atoms,
        i.e. as generated by preprocessing.

    Returns:
    mol - An RDKit Molecule object.
    """

    mol = Chem.RWMol()
    atom_id_to_idx = [None] * hier_graph.number_of_nodes("atom")
    atom_ids = hier_graph.nodes("atom")
    for atom_id in atom_ids:
        try_add_atom(mol, atom_id, atom_id_to_idx, hier_graph, vocabs)
        source_ids, target_ids, edge_ids = hier_graph.out_edges(atom_id, form = "all", etype = ("atom", "bond", "atom"))
        for source_id, target_id, edge_id in zip(source_ids, target_ids, edge_ids):
            try_add_atom(mol, target_id, atom_id_to_idx, hier_graph, vocabs)
            try_add_bond(mol, source_id, target_id, edge_id, atom_id_to_idx, hier_graph, vocabs)

    return mol
